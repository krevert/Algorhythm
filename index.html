<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Cabin">
    <title>Sound Test</title>
    <style type="text/css">
        body {
           background-color: #000;
           font-family: "Cabin", Helvetica, Arial, sans-serif;
           text-align: center;
        }
        #info {
           width: 250px;
           height: 25px;
           background-color: #2f2f2f;
           border: 1px solid;
           border-radius: 20px;
           border-color: #e3e3e3;
           margin-top: 4px;
           margin-left: auto;
           margin-right: auto;
           opacity: 0.8;
        }
        #infotext {
            margin-top: 2px;
            color: #e3e3e3;
        }
        #paintdevice {
            width: 100%;
            height: 100%;
            margin: 4px;
        }

    </style>

    <script type="text/javascript" src="3rdparty/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/loader.js"></script>
    <script type="text/javascript">


    window.onload = function() {

        var canvas;
        var ctx;
        var audioCtx;

        var nodes;
        var intervalId;

        function printErrorMessage(msg) {
            console.log(msg);
        }

        function init() {

            canvas = document.getElementById("paintdevice");
            ctx = canvas.getContext('2d');
            canvas.width  = window.innerWidth  * 0.95;
            canvas.height = window.innerHeight * 0.95;

            audioCtx = webkitAudioContext ? new webkitAudioContext() : null;

            if (!(ctx && audioCtx)) {
                printErrorMessage("Missing canvas and/or audio api =(");
                return;
            }

            window.addEventListener('dragover', function(event) {
                event.preventDefault();
            }, false);

            window.addEventListener('drop', function(event) {
                event.stopPropagation();
                event.preventDefault();
                if (!reset()) {
                    return;
                }
                Loader.loadFile(event.dataTransfer.files, play, printErrorMessage);
            }, false);

            //document.getElementById('openSoundFile').addEventListener('change', function(event) {
            //    if (!reset()) {
            //        return;
            //    }
            //    Loader.loadFile(event.target.files, play, printErrorMessage);
            //}, false);

            //Dat.Gui
            var gui = new GUI();

            ctx.strokeStyle = "hsl(720, 100%, 50%)";
            ctx.fillStyle = document.body.style.backgroundColor;
            ctx.lineWidth = 3;
            ctx.lineJoin = "round";

            //Loader.requestFile("content/CloudCompany.mp3", play, printErrorMessage);

        }

        function reset() {

            if (nodes) {
                for (var i=0; i < nodes.length; i++) {
                    nodes[i].disconnect();
                }
            }

            // it seems that the following lines improve memory footprint,
            // but I have to investigate further here
            delete nodes;
            delete audioCtx;
            nodes = new Array();
            audioCtx = webkitAudioContext ? new webkitAudioContext() : null;
            if (!audioCtx) {
                return false;
            }

            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            if (intervalId) {
                window.clearInterval(intervalId);
                intervalId = undefined;
            }

            return true;

        }

        function processAudioData(nodes) {

            var analyzerNode = audioCtx.createAnalyser();

            var hue;
            var oldHue = -1;
            var runner = 0;

            var fftSize = 750;
            var border = 750;

            var data = new Uint8Array(fftSize);

            var lines = 250;
            var samplesPerLine = Math.floor(border / lines);
            var step = (Math.PI * 8) / lines;

            analyzerNode.fftSize = fftSize;
            analyzerNode.smoothingTimeConstant = 0.75;
            nodes.push(analyzerNode);

            intervalId = window.setInterval(function() {

                ctx.beginPath();

                ctx.globalAlpha = 0.15;
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.fill();
                ctx.globalAlpha = 0.15;

                ctx.beginPath();
                var sum  = 0, len = 0, rot = 0;
                analyzerNode.getByteFrequencyData(data);

                ctx.save();
                ctx.moveTo(canvas.width * 0.5, canvas.height * 0.5);
                for (var j=0; j < border; j++) {
                    sum += data[j];
                    if ((j + 1) % samplesPerLine === 0) {
                        len = sum / samplesPerLine;
                        var scaledLenX = (len / 255) * (canvas.width * 0.75);
                        var scaledLenY = (len / 255) * (canvas.height);
                        var x = (canvas.width * 0.5) - (scaledLenX * Math.cos(rot));
                        var y = (canvas.height  * 0.5) - (scaledLenY * Math.sin(rot));
                        if ((j + 1) === samplesPerLine) {
                            ctx.moveTo(x, y);
                            hue = (len / 255) * 360;
                            if ((runner > 25) && (((hue - oldHue) < 75) || (oldHue === -1))) {
                                ctx.strokeStyle = "hsl(" + hue + ", 100%, 50%)";
                                oldHue = hue;
                            }
                        } else {
                            ctx.shadowColor = "hsl(" + hue + ", 100%, 50%)";;
                            ctx.shadowOffsetX = 8;
                            ctx.shadowOffsetY = 8;
                            ctx.shadowBlur    = 12;
                            ctx.lineTo(x, y);
                        }
                        sum = 0;
                        runner++;
                        rot += step;
                    }
                }
                ctx.stroke();
                ctx.restore();

            }, 50);  //setInterval

        }

        function play(rawBuffer) {

            nodes = new Array;
            var mucke = audioCtx.createBuffer(rawBuffer, false);
            mucke.gain = 1.0;
            //console.log("Sample Rate: " + mucke.sampleRate);
            //console.log("length: " + mucke.length);
            //console.log("duration: " + mucke.duration);
            //console.log("channels: " + mucke.numberOfCannels);

            var source = audioCtx.createBufferSource();
            source.buffer = mucke;
            nodes.push(source);

            //var filter = audioCtx.createBiquadFilter();
            //filter.type = 0;
            //filter.frequency.value = 880;
            //nodes.push(filter);

            processAudioData(nodes);

            for (var i=0; i<nodes.length; i++) {
                if (i === nodes.length - 1) {
                    nodes[i].connect(audioCtx.destination);
                } else {
                    nodes[i].connect(nodes[i + 1]);
                }
            }

            nodes[0].noteOn(0);

        }

        init();

    }

    </script>
</head>

<body>
<div id="container">
<div id="info">
    <p id="infotext"> algorhythm::circles by bekre =) </p>
</div>
</div>
<canvas id="paintdevice">
    Your browser doesn't support the HTML5 Canvas element.
</canvas>
</body>
</html>

